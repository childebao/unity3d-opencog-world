/// Unity3D OpenCog World Embodiment Program
/// Copyright (C) 2013  Novamente
///
/// This program is free software: you can redistribute it and/or modify
/// it under the terms of the GNU Affero General Public License as
/// published by the Free Software Foundation, either version 3 of the
/// License, or (at your option) any later version.
///
/// This program is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU Affero General Public License for more details.
///
/// You should have received a copy of the GNU Affero General Public License
/// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using UnityEditor;
using UnityEngine;
using ProtoBuf;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;

using OpenCog.AttributeExtensions;
using OpenCog.AutomationExtensions;
using OpenCog.SerializationExtensions;

using Type = System.Type;
using Enum = System.Enum;

namespace OpenCog
{

namespace EditorExtensions
{

/// <summary>
/// The OpenCog Editor.  Expands on inspector interface functionality
/// for scripts.  Exposes properties, fixes missing connections, and
/// allows for custom data representations (such as tooltips).
/// Subclasses will be autogenerated for each Mono Behavior script type
/// by the OpenCog Automated Editor Builder.
/// </summary>
#region Class Attributes

[ProtoContract(ImplicitFields = ImplicitFields.AllPublic)]
[CanEditMultipleObjects]
#endregion
public class OCEditor< OCType >
#region Superclass, Generics, and Interfaces
: Editor
, OCBoolPropertyToggleInterface
, OCEnumPropertyToggleInterface
, OCFloatSliderInterface
, OCIntSliderInterface
, OCTooltipInterface
, OCExposePropertiesInterface
, OCDrawMethodInterface
, OCFixMissingScriptsInterface
where OCType : MonoBehaviour
#endregion
{

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Data

	/////////////////////////////////////////////////////////////////////////////

	/// <summary>
	/// The mono behavior instance we're editing.
	/// </summary>
	private OCType m_Instance;

//	/// <summary>
//	/// The accessible and mutable public properties or fields of the instance.
//	/// </summary>
//	private List<OCPropertyField> m_ReadAndWriteProperties;
//
//	/// <summary>
//	/// The constant public properties or fields of the instance.
//	/// </summary>
//	private List<OCPropertyField> m_ReadOnlyProperties;

//	/// <summary>
//	/// The private properties of the instance.
//	/// </summary>
//	private OCPropertyField[] m_PrivateFields;

	private List<OCPropertyField> m_AllPropertyFields = new List<OCPropertyField>();

	/// <summary>
	/// Have we tried to find a suitable script for a missing connection?
	/// </summary>
	private static bool m_HaveTried;

	/// <summary>
	/// The next object to try to find a suitable script for.
	/// </summary>
	private static GameObject m_TryThisObject;


	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Accessors and Mutators

	/////////////////////////////////////////////////////////////////////////////

	/// <summary>
	/// Gets or sets a value indicating whether these
	/// <see cref="OpenCog.OCEditor`1"/>s have tried.
	/// </summary>
	/// <value>
	/// <c>true</c> if have tried; otherwise, <c>false</c>.
	/// </value>
	public static bool HaveTried
	{
		get { return m_HaveTried;}
		set { m_HaveTried = value;}
	}

	/// <summary>
	/// Gets or sets the next object to try.
	/// </summary>
	/// <value>
	/// The try this object.
	/// </value>
	public static GameObject TryThisObject
	{
		get { return m_TryThisObject;}
		set { m_TryThisObject = value;}
	}

	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Public Member Functions

	/////////////////////////////////////////////////////////////////////////////

	public void OnEnable()
	{
		m_Instance = target as OCType;



		OCAutomatedScriptScanner.Initialize();
	}
 
	public override void OnInspectorGUI()
	{
		// Update the serializedObject - always do this in the beginning of
		// OnInspectorGUI.
		serializedObject.Update();

		SerializedProperty unityPropertyField = serializedObject.GetIterator();

		List<OCPropertyField> allPropertyFields = new List<OCPropertyField>();

		System.Type exposePropertiesType =
			typeof(OpenCog.AttributeExtensions.OCExposePropertiesAttribute);

		object[] attributes = null;

		if(exposePropertiesType != null)
			attributes =
				m_Instance
			.	GetType()
			.	GetCustomAttributes(exposePropertiesType, true)
			;

		if(attributes != null && attributes.Length > 0)
		{
			bool success =
				OCPropertyField.GetAllPropertiesAndFields
				(
					ref allPropertyFields
				, m_Instance
				, unityPropertyField
				)
			;
		}
		// Tests if there is a missing script
		if(AreAnyScriptsMissing())
		{
			FindMissingScripts(allPropertyFields);
		}

		DrawSerializedProperties(allPropertyFields);

		// Apply changes to the serializedProperty - always do this in the end of
		// OnInspectorGUI.
		serializedObject.ApplyModifiedProperties();
		serializedObject.UpdateIfDirtyOrScript();
	}

	public void DrawSerializedProperties(List< OCPropertyField > allPropertiesAndFields)
	{
		GUIContent content = new GUIContent();
		GUILayoutOption[] emptyOptions = new GUILayoutOption[0];

		EditorGUILayout.BeginVertical(emptyOptions);

		//Loops through all visible fields
		foreach(OCPropertyField propertyField in allPropertiesAndFields)
		{
			EditorGUILayout.BeginHorizontal(emptyOptions);

			//Finds the bool Condition, enum Condition and tooltip if they exist (They are null otherwise).
			OCBoolPropertyToggleAttribute boolCondition = getAttribute<OCBoolPropertyToggleAttribute>(propertyField);
			OCEnumPropertyToggleAttribute enumCondition = getAttribute<OCEnumPropertyToggleAttribute>(propertyField);
			OCDrawMethodAttribute drawMethod = getAttribute<OCDrawMethodAttribute>(propertyField);
			OCTooltipAttribute tooltip = getAttribute<OCTooltipAttribute>(propertyField);
			OCFloatSliderAttribute floatSlider = getAttribute<OCFloatSliderAttribute>(propertyField);
			OCIntSliderAttribute intSlider = getAttribute<OCIntSliderAttribute>(propertyField);

			//Evaluates the enum and bool conditions
			bool allowedVisibleForBoolCondition = AllowedVisibleForBoolCondition(propertyField, boolCondition);
			bool allowedVisibleForEnumCondition = AllowedVisibleForEnumCondition(propertyField, enumCondition);

			//Tests is the field is visible
			if(allowedVisibleForBoolCondition && allowedVisibleForEnumCondition && drawMethod == null)
			{

				content.text = propertyField.PublicName;

				//Sets the tooltip if avaiable
				if(tooltip != null)
				{
					content.tooltip = tooltip.Tooltip;
				}

				DrawFieldInInspector(propertyField, content, emptyOptions, floatSlider, intSlider);

			}
			else
			if(drawMethod != null)
			{
				// If the user wants to draw the field himself.
				MethodInfo drawMethodInfo = this.GetType().GetMethod(drawMethod.DrawMethod);
				if(drawMethodInfo == null)
				{
					Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. Could not find the method '" + drawMethod.DrawMethod + "' in the " + this.ToString() + ". The attribute is attached to the field '" + propertyField.PublicName + "' in '" + propertyField.UnityPropertyField.serializedObject.targetObject + "'.");
					continue;
				}
				ParameterInfo[] parametersInfo = drawMethodInfo.GetParameters();
				if(parametersInfo.Length != (drawMethod.Parameters as object[]).Length)
				{
					Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. The number of parameters in the attribute, did not match the number of parameters in the actual method. The attribute is attached to the field '" + propertyField.PublicName + "' in '" + propertyField.UnityPropertyField.serializedObject.targetObject + "'.");
					continue;
				}

				bool _error = false;
				for(int i = 0; i < parametersInfo.Length; i++)
				{
					//Makes sure the parameter of the actual method is equal to the
					if(!Type.Equals(parametersInfo[i].ParameterType, drawMethod.Parameters[i].GetType()))
					{
						_error = true;
						Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. The parameter type ('" + drawMethod.Parameters[i].GetType() + "') in the attribute, did not match the the parameter type ('" + parametersInfo[i].ParameterType + "') of the actual method, parameter index: '" + i + "'. The attribute is attached to the field '" + propertyField.PublicName + "' in '" + propertyField.UnityPropertyField.serializedObject.targetObject + "'.");
						continue;
					}
				}
				if(_error)
				{
					continue;
				}

				// VVVVV Calls the users own method  VVVVV
				drawMethodInfo.Invoke(this, drawMethod.Parameters);
				// ^^^^^ Calls the users own method ^^^^^
			}

			EditorGUILayout.EndHorizontal();

		}

		EditorGUILayout.EndVertical();
	}

	public void DrawFieldInInspector(OCPropertyField propertyField, GUIContent content, GUILayoutOption[] emptyOptions, OCFloatSliderAttribute floatSlider, OCIntSliderAttribute intSlider)
	{
		if(floatSlider != null)
		{
			var currentTarget = m_Instance;
			MemberInfo[] memberInfo = currentTarget.GetType().GetMember(propertyField.PrivateName, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public);
			//Tests if the field is not a float, if so it will display an error
//			if
//			(		memberInfo == null
//			|| ((memberInfo[0] as FieldInfo) == null && (memberInfo[0] as PropertyInfo) == null)
//			|| ((memberInfo[0] as FieldInfo).FieldType != typeof(float) && (memberInfo[0] as PropertyInfo).PropertyType != typeof(float))
//			)
//			{
//				Debug.LogError("The '[FloatSliderInInspector(" + floatSlider.MinValue + " ," + floatSlider.MaxValue + ")]' failed. FloatSliderInInspector does not work with the type '" + memberInfo[0].MemberType + "', it only works with float. The attribute is attached to the field '" + propertyField.Name + "' in '" + m_Instance + "'.");
//				return;
//			}
			propertyField.SetValue(EditorGUILayout.Slider(content, (float)propertyField.GetValue(), floatSlider.MinValue, floatSlider.MaxValue));

		}
		else
		if(intSlider != null)
		{
			var currentTarget = m_Instance;
			MemberInfo[] memberInfo = currentTarget.GetType().GetMember(propertyField.PrivateName, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public);
			//Tests if the field is not a int, if so it will display an error
//			if
//			(		memberInfo == null
//			|| ((memberInfo[0] as FieldInfo) == null && (memberInfo[0] as PropertyInfo) == null)
//			|| ((memberInfo[0] as FieldInfo).FieldType != typeof(int) && (memberInfo[0] as PropertyInfo).PropertyType != typeof(int))
//			)
//			{
//				Debug.LogError("The '[IntSliderInInspector(" + intSlider.MinValue + " ," + intSlider.MaxValue + ")]' failed. IntSliderInInspector does not work with the type '" + memberInfo[0].MemberType + "', it only works with int. The attribute is attached to the field '" + propertyField.Name + "' in '" + m_Instance + "'.");
//				return;
//			}
			propertyField.SetValue(EditorGUILayout.IntSlider(content, (int)propertyField.GetValue(), intSlider.MinValue, intSlider.MaxValue));
		}
		else
		if(propertyField.UnityPropertyField != null)
		{
			// VVVV DRAWS THE STANDARD FIELD  VVVV
			EditorGUILayout.PropertyField(propertyField.UnityPropertyField, content, true);
			// ^^^^^  DRAWS THE STANDARD FIELD  ^^^^^
		}
		else
		{
			switch(propertyField.UnityType)
			{
			case SerializedPropertyType.Integer:
				propertyField.SetValue(EditorGUILayout.IntField(content, (int)propertyField.GetValue(), emptyOptions));
				break;
 
			case SerializedPropertyType.Float:
				propertyField.SetValue(EditorGUILayout.FloatField(content, (float)propertyField.GetValue(), emptyOptions));
				break;
 
			case SerializedPropertyType.Boolean:
				propertyField.SetValue(EditorGUILayout.Toggle(content, (bool)propertyField.GetValue(), emptyOptions));
				break;
 
			case SerializedPropertyType.String:
				propertyField.SetValue(EditorGUILayout.TextField(content, (string)propertyField.GetValue(), emptyOptions));
				break;

			case SerializedPropertyType.Vector2:
				propertyField.SetValue(EditorGUILayout.Vector2Field(propertyField.PublicName, (Vector2)propertyField.GetValue(), emptyOptions));
				break;

			case SerializedPropertyType.Vector3:
				propertyField.SetValue(EditorGUILayout.Vector3Field(propertyField.PublicName, (Vector3)propertyField.GetValue(), emptyOptions));
				break;
 
 
 
			case SerializedPropertyType.Enum:
				propertyField.SetValue(EditorGUILayout.EnumPopup(content, (Enum)propertyField.GetValue(), emptyOptions));
				break;
 
			default:
 
				break;
 
			}
		}
	}
  
	/// <summary>
	/// Gets the attribute of type T attached to the SerializedProperty.
	/// </summary>
	/// <returns>
	/// The attribute of type T.
	/// </returns>
	/// <param name='propertyField'>
	/// The Serialized Property.
	/// </param>
	/// <typeparam name='T'>
	/// The type of attribute to find.
	/// </typeparam>
	public T getAttribute<T>(OCPropertyField propertyField)
	{
		Type t = typeof(T);

		if(propertyField == null)
		{
//			Debug.Log("In OCEditor.getAttribute, no propertyField" + ", " + t.ToString());
			return default(T);
		}

		var currentTarget = m_Instance;

		if(currentTarget == null)
		{
//			Debug.Log("In OCEditor.getAttribute, no currentTarget: " + propertyField.Name + ", " + t.ToString());
			return default(T);
		}

		//Retires the fieldInfo for the current field
		MemberInfo[] memberInfo = currentTarget.GetType().GetMember(propertyField.PrivateName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic);
     
		//If there is no field, Unity might find non-fields it wants to display(like script name).
		if(memberInfo == null || memberInfo.Length == 0)
		{
//			Debug.Log("In OCEditor.getAttribute, no memberInfo: " + propertyField.Name + ", " + t.ToString());
			return default(T);
		}
     
		//Findes all attributes of type T attached to the field
		T[] attributes = memberInfo[0].GetCustomAttributes(typeof(T), true) as T[];
     
		if(attributes == null || attributes.Length == 0)
		{
//			Debug.Log("In OCEditor.getAttribute, no attributes: " + propertyField.Name + ", " + t.ToString());
			return default(T);
		}
  
		//returns the tooltip
		return attributes[0];
	}
  
	public bool AllowedVisibleForEnumCondition(OCPropertyField property, OCEnumPropertyToggleAttribute enumCondition)
	{
		// If there is no enumCondition, it is allowed to be visible, there is nothing to hide it.
		if(enumCondition == null)
		{
			return true;
		}
     
		var currentTarget = property.UnityPropertyField.serializedObject.targetObject;
  
		//Retires the fieldInfo for the enum field
		FieldInfo enumFieldInfo = currentTarget.GetType().GetField(enumCondition.EnumField);
     
		if(enumFieldInfo == null)
		{
			//If the field in boolCondition.BooleanField doesn't exist.
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The field '" + enumCondition.EnumField + "' does not exisit in '" + currentTarget + "'.");
			return true;
		}
  
		if(!enumFieldInfo.FieldType.IsEnum)
		{
			//If the wanted field is not a enum
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The field '" + enumCondition.EnumField + "' is not a enum in '" + currentTarget + "'.");
			return true;
		}

		if(!enumCondition.EnumValue.GetType().IsEnum)
		{
			//If the wanted value is not a enum
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The '" + enumCondition.EnumValue + "' is not a enum value in '" + currentTarget + "'.");
			return true;
		}
  
		//Tests if the fields current value is equal to the value it should be to be shown
		if(Enum.Equals(enumFieldInfo.GetValue(currentTarget), enumCondition.EnumValue))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
  
	public bool AllowedVisibleForBoolCondition(OCPropertyField propertyField, OCBoolPropertyToggleAttribute boolCondition)
	{
		// If there is no boolCondition, it is allowed to be visible, there is nothing to hide it.
		if(boolCondition == null || propertyField == null || propertyField.UnityType != SerializedPropertyType.Boolean)
		{
			return true;
		}
     
//		var currentTarget = property.SerializedPropertyReference.serializedObject.targetObject;
//  
//		//Retires the fieldInfo for the boolean field
//		FieldInfo boolInfo = currentTarget.GetType().GetField(boolCondition.BooleanField);
//     
//		if(boolInfo == null)
//		{
//			//If the field in boolCondition.BooleanField doesn't exist.
//			Debug.LogError("The '[ShowInInspectorIfBool(" + boolCondition.BooleanField + ", " + boolCondition.EqualsValue + ")]' failed. The field '" + boolCondition.BooleanField + "' does not exisit in '" + currentTarget + "'.");
//			return true;
//		}
//     
//		if(boolInfo.FieldType != typeof(bool) && boolInfo.FieldType != typeof(Boolean))
//		{
//			//If the wanted field is not a bool
//			Debug.LogError("The '[ShowInInspectorIfBool(" + boolCondition.BooleanField + ", " + boolCondition.EqualsValue + ")]' failed. The field '" + boolCondition.BooleanField + "' is not a type of bool in '" + currentTarget + "'.");
//			return true;
//		}
     
		//Finds the current value
		bool currentValue = (bool)propertyField.GetValue();
     
		//Tests if the current Value is equal to the value it should be to be shown
		if(currentValue == boolCondition.EqualsValue)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
   
	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Classes

	/////////////////////////////////////////////////////////////////////////////



	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Functions

	/////////////////////////////////////////////////////////////////////////////

	private void FindMissingScripts(List< OCPropertyField > allProperties)
	{
		EditorPrefs.SetBool("Fix", GUILayout.Toggle(EditorPrefs.GetBool("Fix", true), "Fix broken scripts"));
		if(!EditorPrefs.GetBool("Fix", true))
		{
			GUILayout.Label("*** SCRIPT MISSING ***");
			return;
		}

		foreach(OCPropertyField property in allProperties)
		{
			//Debug.Log("In OCEditor.FindMissingScripts(), property name: " + property.name);
			if(property.PublicName == "Script" && property.MemberInfo == null)
			{
				//Debug.Log("In OCEditor.FindMissingScripts(), found script");
				Component targetComponent = target as Component;
				if(targetComponent != null && TryThisObject == targetComponent.gameObject)
				{
					//Debug.Log("In OCEditor.FindMissingScripts(), we have tried this script already");
					HaveTried = true;
				}

				List< OCScript > candidates = OCAutomatedScriptScanner.Scripts.ToList();

				foreach(OCPropertyField subProperty in allProperties)
				{
					if(candidates.Count == 0)
					{
						break;
					}
					if(subProperty.PublicName != "Script")
					{
						candidates = candidates.Where(c => c.Properties.ContainsKey(subProperty.PublicName)).ToList();
					}
				}

				if(candidates.Count == 1)
				{
					property.SetValue(candidates[0].Script);

					serializedObject.ApplyModifiedProperties();
					serializedObject.UpdateIfDirtyOrScript();
				}
				else
				if(candidates.Count > 0)
				{
					foreach(OCScript candidate in candidates)
					{
						if(candidate != null && candidate.Script != null && GUILayout.Button("Use " + candidate.Script.name))
						{
							//Configure the script
							property.SetValue(candidate.Script);

							serializedObject.ApplyModifiedProperties();
							serializedObject.UpdateIfDirtyOrScript();
    
						}
					}
				}
				else
				{
					GUILayout.Label("> No suitable scripts were found");
				}
				break;
			}
		}

//		var iterator = this.serializedObject.GetIterator();
//		var first = true;
//		while(iterator.NextVisible(first))
//		{
//			first = false;
//			if(iterator.name == "m_Script" && iterator.objectReferenceValue == null)
//			{
//				if((target as Component) != null && TryThisObject == (target as Component).gameObject)
//				{
//					HaveTried = true;
//				}
//
//				//Make a copy of our script serialized property
//				//for later
//				var script = iterator.Copy();
//
//				//Get a copy of all of the scripts
//				var candidates = OCAutomatedScriptScanner.Scripts.ToList();
//
//				//Step through the remaining properties
//				//while we have anything that might match
//				while(iterator.NextVisible(false) && candidates.Count>0)
//				{
//					//Set candidates to the subset that contain
//					//the current property
//					candidates = candidates.Where(c => c.Properties.ContainsKey(iterator.name)).ToList();
//				}
//				//If we have only 1 candidate remaining
//				//then use it
//				if(candidates.Count == 1)
//				{
//					//Set the script reference
//					script.objectReferenceValue = candidates[0].Script;
//    
//					//Update the data stream
//					serializedObject.ApplyModifiedProperties();
//					serializedObject.UpdateIfDirtyOrScript();
//
//				}
//        //If we have multiple matches then give
//        //the user a choice
//				else
//				if(candidates.Count > 0)
//				{
//					foreach(var candidate in candidates)
//					{
//						if(candidate != null && candidate.Script != null && GUILayout.Button("Use " + candidate.Script.name))
//						{
//							//Configure the script
//							script.objectReferenceValue = candidate.Script;
//
//							serializedObject.ApplyModifiedProperties();
//							serializedObject.UpdateIfDirtyOrScript();
//    
//						}
//					}
//				}
//        //Otherwise tell them we failed
//				else
//				{
//					GUILayout.Label("> No suitable scripts were found");
//				}
//				break;
//			}
//		}
	}

	private bool AreAnyScriptsMissing()
	{
		//@TODO: fix this test
		return target.GetType() != typeof(OCType) || target.GetType() == typeof(MonoBehaviour);
	}

//	void DisplayInspectorGUI()
//	{
//		//base.OnInspectorGUI();
//		DrawDefaultInspector();
//
//		OCExposePropertiesAttribute.Expose(m_ReadAndWriteProperties);
//	}

	void SerializeAndHidePrivateDataMembers(System.Object obj)
	{
		if(obj == null)
		{
			return;
		}
 
		List< FieldInfo > fields = new List<FieldInfo>();
 
		Type objType = obj.GetType();

		FieldInfo[] infos = objType.GetFields
    (
      BindingFlags.NonPublic
    | BindingFlags.Instance
    );

		foreach(FieldInfo info in infos)
		{

			object[] attributes = info.GetCustomAttributes(true);

		}




	}





	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

}// class OCEditor

}// namespace EditorExtensions

}// namespace OpenCog