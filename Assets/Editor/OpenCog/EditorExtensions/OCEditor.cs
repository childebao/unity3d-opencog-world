/// Unity3D OpenCog World Embodiment Program
/// Copyright (C) 2013  Novamente
///
/// This program is free software: you can redistribute it and/or modify
/// it under the terms of the GNU Affero General Public License as
/// published by the Free Software Foundation, either version 3 of the
/// License, or (at your option) any later version.
///
/// This program is distributed in the hope that it will be useful,
/// but WITHOUT ANY WARRANTY; without even the implied warranty of
/// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
/// GNU Affero General Public License for more details.
///
/// You should have received a copy of the GNU Affero General Public License
/// along with this program.  If not, see <http://www.gnu.org/licenses/>.

using UnityEditor;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System;
using ProtoBuf;
using OpenCog.AttributeExtensions;
using OpenCog.AutomationExtensions;
using OpenCog.SerializationExtensions;

namespace OpenCog
{

namespace EditorExtensions
{

/// <summary>
/// The OpenCog Editor.  Expands on inspector interface functionality
/// for scripts.  Exposes properties, fixes missing connections, and
/// allows for custom data representations (such as tooltips).
/// Subclasses will be autogenerated for each Mono Behavior script type
///
/// </summary>

#region Class Attributes

[ProtoContract(ImplicitFields = ImplicitFields.AllPublic)]
[CanEditMultipleObjects]
#endregion
public class OCEditor< OCType >
#region Superclass, Generics, and Interfaces
: Editor
, OCBoolPropertyToggleInterface
, OCEnumPropertyToggleInterface
, OCFloatSliderInterface
, OCIntSliderInterface
, OCTooltipInterface
, OCExposePropertiesInterface
, OCDrawMethodInterface
, OCFixMissingScriptsInterface
where OCType : MonoBehaviour
#endregion
{

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Data

	/////////////////////////////////////////////////////////////////////////////

	/// <summary>
	/// The mono behavior instance we're editing.
	/// </summary>
	private OCType m_Instance;

	/// <summary>
	/// The mutable public properties of the instance.
	/// </summary>
	private OCPropertyField[] m_ReadAndWriteProperties;

	/// <summary>
	/// The constant public properties of the instance.
	/// </summary>
	private OCPropertyField[] m_ReadOnlyProperties;

	/// <summary>
	/// The private properties of the instance.
	/// </summary>
	private OCPropertyField[] m_PrivateFields;

	/// <summary>
	/// Have we tried to find a suitable script for a missing connection?
	/// </summary>
	private static bool m_HaveTried;

	/// <summary>
	/// The next object to try to find a suitable script for.
	/// </summary>
	private static GameObject m_TryThisObject;


	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Accessors and Mutators

	/////////////////////////////////////////////////////////////////////////////

	/// <summary>
	/// Gets or sets a value indicating whether these
	/// <see cref="OpenCog.OCEditor`1"/>s have tried.
	/// </summary>
	/// <value>
	/// <c>true</c> if have tried; otherwise, <c>false</c>.
	/// </value>
	public static bool HaveTried
	{
		get { return m_HaveTried;}
		set { m_HaveTried = value;}
	}

	/// <summary>
	/// Gets or sets the next object to try.
	/// </summary>
	/// <value>
	/// The try this object.
	/// </value>
	public static GameObject TryThisObject
	{
		get { return m_TryThisObject;}
		set { m_TryThisObject = value;}
	}

	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Public Member Functions

	/////////////////////////////////////////////////////////////////////////////

	public void OnEnable()
	{
		m_Instance = target as OCType;
		bool success = OCExposePropertiesAttribute.GetProperties(m_Instance, out m_ReadOnlyProperties, out m_ReadAndWriteProperties);
		OCAutomatedScriptScanner.Initialize();
	}
 
	public override void OnInspectorGUI()
	{
		// Update the serializedObject - always do this in the beginning of
		// OnInspectorGUI.
		serializedObject.Update();

		SerializedProperty serializedPropertyIterator = serializedObject.GetIterator();

		List< OCPropertyField > allProperties = new List<OCPropertyField>();

		allProperties.AddRange(m_ReadOnlyProperties);
		allProperties.AddRange(m_ReadAndWriteProperties);

		while(serializedPropertyIterator.NextVisible(true))
		{
			OCPropertyField property = new OCPropertyField(serializedPropertyIterator.Copy());
			if(allProperties.Find(p => p.Name == property.Name) == null)
				allProperties.Add(property);
		}

		// Tests if there is a missing script
		if(AreAnyScriptsMissing())
		{
			FindMissingScripts(allProperties);
		}

		DrawSerializedProperties(allProperties);

		OCExposePropertiesAttribute.Expose(allProperties);

		// Apply changes to the serializedProperty - always do this in the end of
		// OnInspectorGUI.
		serializedObject.ApplyModifiedProperties();
		serializedObject.UpdateIfDirtyOrScript();
	}

	public void DrawSerializedProperties(List< OCPropertyField > allProperties)
	{
		GUIContent g_content = new GUIContent();
		GUILayoutOption[] emptyOptions = new GUILayoutOption[0];

		EditorGUILayout.BeginVertical(emptyOptions);

		//Loops through all visible fields
		foreach(OCPropertyField property in allProperties)
		{
			EditorGUILayout.BeginHorizontal(emptyOptions);

			//Finds the bool Condition, enum Condition and tooltip if they exists (They are null otherwise).
			OCBoolPropertyToggleAttribute boolCondition = getAttribute<OCBoolPropertyToggleAttribute>(property);
			OCEnumPropertyToggleAttribute enumCondition = getAttribute<OCEnumPropertyToggleAttribute>(property);
			OCDrawMethodAttribute drawMethod = getAttribute<OCDrawMethodAttribute>(property);
			OCTooltipAttribute tooltip = getAttribute<OCTooltipAttribute>(property);
			OCFloatSliderAttribute floatSlider = getAttribute<OCFloatSliderAttribute>(property);
			OCIntSliderAttribute intSlider = getAttribute<OCIntSliderAttribute>(property);

			//Evaluates the enum and bool conditions
			bool allowedVisibleForBoolCondition = AllowedVisibleForBoolCondition(property, boolCondition);
			bool allowedVisibleForEnumCondition = AllowedVisibleForEnumCondition(property, enumCondition);

			//Tests is the field is visible
			if(allowedVisibleForBoolCondition && allowedVisibleForEnumCondition && drawMethod == null)
			{

				g_content.text = ObjectNames.NicifyVariableName(property.name);

				//Sets the tooltip if avaiable
				if(tooltip != null)
				{
					g_content.tooltip = tooltip.Tooltip;
				}

				DrawFieldInInspector(property, g_content, emptyOptions, floatSlider, intSlider);

			}
			else
			if(drawMethod != null)
			{
				// If the user wants to draw the field himself.
				MethodInfo drawMethodInfo = this.GetType().GetMethod(drawMethod.DrawMethod);
				if(drawMethodInfo == null)
				{
					Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. Could not find the method '" + drawMethod.DrawMethod + "' in the " + this.ToString() + ". The attribute is attached to the field '" + property.name + "' in '" + property.serializedObject.targetObject + "'.");
					continue;
				}
				ParameterInfo[] parametersInfo = drawMethodInfo.GetParameters();
				if(parametersInfo.Length != (drawMethod.Parameters as object[]).Length)
				{
					Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. The number of parameters in the attribute, did not match the number of parameters in the actual method. The attribute is attached to the field '" + property.name + "' in '" + property.serializedObject.targetObject + "'.");
					continue;
				}

				bool _error = false;
				for(int i = 0; i < parametersInfo.Length; i++)
				{
					//Makes sure the parameter of the actual method is equal to the
					if(!Type.Equals(parametersInfo[i].ParameterType, drawMethod.Parameters[i].GetType()))
					{
						_error = true;
						Debug.LogError("The '[CustomDrawMethod(" + drawMethod.DrawMethod + "" + drawMethod.ParametersToString() + ")]' failed. The parameter type ('" + drawMethod.Parameters[i].GetType() + "') in the attribute, did not match the the parameter type ('" + parametersInfo[i].ParameterType + "') of the actual method, parameter index: '" + i + "'. The attribute is attached to the field '" + property.name + "' in '" + property.serializedObject.targetObject + "'.");
						continue;
					}
				}
				if(_error)
				{
					continue;
				}

				// VVVVV Calls the users own method  VVVVV
				drawMethodInfo.Invoke(this, drawMethod.Parameters);
				// ^^^^^ Calls the users own method ^^^^^
			}

			EditorGUILayout.EndHorizontal();

		}

		EditorGUILayout.EndVertical();
	}

	public void DrawFieldInInspector(SerializedProperty s_property, GUIContent g_content, GUILayoutOption[] emptyOptions, OCFloatSliderAttribute floatSlider, OCIntSliderAttribute intSlider)
	{
		if(floatSlider != null)
		{
			var currentTarget = s_property.serializedObject.targetObject;
			FieldInfo fieldInfo = currentTarget.GetType().GetField(s_property.name);
			//Tests if the field is not a float, if so it will display an error
			if(fieldInfo.FieldType != typeof(float))
			{
				Debug.LogError("The '[FloatSliderInInspector(" + floatSlider.MinValue + " ," + floatSlider.MaxValue + ")]' failed. FloatSliderInInspector does not work with the type '" + fieldInfo.FieldType + "', it only works with float. The attribute is attached to the field '" + s_property.name + "' in '" + s_property.serializedObject.targetObject + "'.");
				return;
			}
			EditorGUILayout.Slider(s_property, floatSlider.MinValue, floatSlider.MaxValue, g_content);

		}
		else
		if(intSlider != null)
		{
			var currentTarget = s_property.serializedObject.targetObject;
			FieldInfo fieldInfo = currentTarget.GetType().GetField(s_property.name);
			//Tests if the field is not a int, if so it will display an error
			if(fieldInfo.FieldType != typeof(int))
			{
				Debug.LogError("The '[IntSliderInInspector(" + intSlider.MinValue + " ," + intSlider.MaxValue + ")]' failed. IntSliderInInspector does not work with the type '" + fieldInfo.FieldType + "', it only works with int. The attribute is attached to the field '" + s_property.name + "' in '" + s_property.serializedObject.targetObject + "'.");
				return;
			}
			EditorGUILayout.IntSlider(s_property, intSlider.MinValue, intSlider.MaxValue, g_content);
		}
		else
		{
			// VVVV DRAWS THE STANDARD FIELD  VVVV
			EditorGUILayout.PropertyField(s_property, g_content, true);
			// ^^^^^  DRAWS THE STANDARD FIELD  ^^^^^
		}   
	}
  
	/// <summary>
	/// Gets the attribute of type T attached to the SerializedProperty.
	/// </summary>
	/// <returns>
	/// The attribute of type T.
	/// </returns>
	/// <param name='property'>
	/// The Serialized Property.
	/// </param>
	/// <typeparam name='T'>
	/// The type of attribute to find.
	/// </typeparam>
	public T getAttribute<T>(OCPropertyField property)
	{
		if(property == null)
		{
			return default(T);
		}

		var currentTarget = property.SerializedPropertyReference.serializedObject.targetObject;

		if(currentTarget == null)
		{
			return default(T);
		}

		//Retires the fieldInfo for the current field
		FieldInfo fieldInfo = currentTarget.GetType().GetField(property.SerializedPropertyReference.name);
     
		//If there is no field, Unity might find non-fields it wants to display(like script name).
		if(fieldInfo == null)
		{
			return default(T);
		}
     
		//Findes all attributes of type T attached to the field
		T[] attributes = fieldInfo.GetCustomAttributes(typeof(T), true) as T[];
     
		if(attributes == null)
		{
			return default(T);
		}
     
		if(attributes.Length == 0)
		{
			return default(T);
		}
  
		//returns the tooltip
		return attributes[0];
	}
  
	public bool AllowedVisibleForEnumCondition(SerializedProperty s_property, OCEnumPropertyToggleAttribute enumCondition)
	{
		// If there is no enumCondition, it is allowed to be visible, there is nothing to hide it.
		if(enumCondition == null)
		{
			return true;
		}
     
		var currentTarget = s_property.serializedObject.targetObject;
  
		//Retires the fieldInfo for the enum field
		FieldInfo enumFieldInfo = currentTarget.GetType().GetField(enumCondition.EnumField);
     
		if(enumFieldInfo == null)
		{
			//If the field in boolCondition.BooleanField doesn't exist.
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The field '" + enumCondition.EnumField + "' does not exisit in '" + currentTarget + "'.");
			return true;
		}
  
		if(!enumFieldInfo.FieldType.IsEnum)
		{
			//If the wanted field is not a enum
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The field '" + enumCondition.EnumField + "' is not a enum in '" + currentTarget + "'.");
			return true;
		}

		if(!enumCondition.EnumValue.GetType().IsEnum)
		{
			//If the wanted value is not a enum
			Debug.LogError("The '[ShowInInspectorIfEnum(" + enumCondition.EnumField + ", " + enumCondition.EnumValue + ")]' failed. The '" + enumCondition.EnumValue + "' is not a enum value in '" + currentTarget + "'.");
			return true;
		}
  
		//Tests if the fields current value is equal to the value it should be to be shown
		if(Enum.Equals(enumFieldInfo.GetValue(currentTarget), enumCondition.EnumValue))
		{
			return true;
		}
		else
		{
			return false;
		}
	}
  
	public bool AllowedVisibleForBoolCondition(SerializedProperty s_property, OCBoolPropertyToggleAttribute boolCondition)
	{
		// If there is no boolCondition, it is allowed to be visible, there is nothing to hide it.
		if(boolCondition == null)
		{
			return true;
		}
     
		var currentTarget = s_property.serializedObject.targetObject;
  
		//Retires the fieldInfo for the boolean field
		FieldInfo boolInfo = currentTarget.GetType().GetField(boolCondition.BooleanField);
     
		if(boolInfo == null)
		{
			//If the field in boolCondition.BooleanField doesn't exist.
			Debug.LogError("The '[ShowInInspectorIfBool(" + boolCondition.BooleanField + ", " + boolCondition.EqualsValue + ")]' failed. The field '" + boolCondition.BooleanField + "' does not exisit in '" + currentTarget + "'.");
			return true;
		}
     
		if(boolInfo.FieldType != typeof(bool) && boolInfo.FieldType != typeof(Boolean))
		{
			//If the wanted field is not a bool
			Debug.LogError("The '[ShowInInspectorIfBool(" + boolCondition.BooleanField + ", " + boolCondition.EqualsValue + ")]' failed. The field '" + boolCondition.BooleanField + "' is not a type of bool in '" + currentTarget + "'.");
			return true;
		}
     
		//Finds the current value
		bool currentValue = (bool)boolInfo.GetValue(currentTarget);
     
		//Tests if the current Value is equal to the value it should be to be shown
		if(currentValue == boolCondition.EqualsValue)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
   
//	public String CreateReadableName(string baseName)
//	{
//		string readableName = "";
//		readableName += char.ToUpper(baseName[0]);
//     
//		for(int i = 1; i < baseName.Length; i++)
//		{
//			//Adds a space if (The current letter is uppercase OR number) AND the previous added letter was lowercase
//			if((char.IsUpper(baseName[i]) || char.IsNumber(baseName[i])) && char.IsLower(readableName[readableName.Length - 1]))
//			{
//				readableName += " ";
//			}
//			readableName += baseName[i]; 
//		}
//     
//		return readableName;
//	}

	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Classes

	/////////////////////////////////////////////////////////////////////////////



	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

  #region Private Member Functions

	/////////////////////////////////////////////////////////////////////////////

	private void FindMissingScripts(List< OCPropertyField > allProperties)
	{
		EditorPrefs.SetBool("Fix", GUILayout.Toggle(EditorPrefs.GetBool("Fix", true), "Fix broken scripts"));
		if(!EditorPrefs.GetBool("Fix", true))
		{
			GUILayout.Label("*** SCRIPT MISSING ***");
			return;
		}

		foreach(OCPropertyField property in allProperties)
		{
			//Debug.Log("In OCEditor.FindMissingScripts(), property name: " + property.name);
			if(property.Name == "Script" && property.IsNull())
			{
				//Debug.Log("In OCEditor.FindMissingScripts(), found script");
				Component targetComponent = target as Component;
				if(targetComponent != null && TryThisObject == targetComponent.gameObject)
				{
					//Debug.Log("In OCEditor.FindMissingScripts(), we have tried this script already");
					HaveTried = true;
				}

				List< OCScript > candidates = OCAutomatedScriptScanner.Scripts.ToList();

				foreach(OCPropertyField subProperty in allProperties)
				{
					if(candidates.Count == 0)
					{
						break;
					}
					if(subProperty.Name != "Script")
					{
						candidates = candidates.Where(c => c.Properties.ContainsKey(subProperty.Name)).ToList();
					}
				}

				if(candidates.Count == 1)
				{
					property.SetValue( candidates[0].Script );

					serializedObject.ApplyModifiedProperties();
					serializedObject.UpdateIfDirtyOrScript();
				}
				else
				if(candidates.Count > 0)
				{
					foreach(OCScript candidate in candidates)
					{
						if(candidate != null && candidate.Script != null && GUILayout.Button("Use " + candidate.Script.name))
						{
							//Configure the script
							property.SetValue( candidate.Script );

							serializedObject.ApplyModifiedProperties();
							serializedObject.UpdateIfDirtyOrScript();
    
						}
					}
				}
				else
				{
					GUILayout.Label("> No suitable scripts were found");
				}
				break;
			}
		}

//		var iterator = this.serializedObject.GetIterator();
//		var first = true;
//		while(iterator.NextVisible(first))
//		{
//			first = false;
//			if(iterator.name == "m_Script" && iterator.objectReferenceValue == null)
//			{
//				if((target as Component) != null && TryThisObject == (target as Component).gameObject)
//				{
//					HaveTried = true;
//				}
//
//				//Make a copy of our script serialized property
//				//for later
//				var script = iterator.Copy();
//
//				//Get a copy of all of the scripts
//				var candidates = OCAutomatedScriptScanner.Scripts.ToList();
//
//				//Step through the remaining properties
//				//while we have anything that might match
//				while(iterator.NextVisible(false) && candidates.Count>0)
//				{
//					//Set candidates to the subset that contain
//					//the current property
//					candidates = candidates.Where(c => c.Properties.ContainsKey(iterator.name)).ToList();
//				}
//				//If we have only 1 candidate remaining
//				//then use it
//				if(candidates.Count == 1)
//				{
//					//Set the script reference
//					script.objectReferenceValue = candidates[0].Script;
//    
//					//Update the data stream
//					serializedObject.ApplyModifiedProperties();
//					serializedObject.UpdateIfDirtyOrScript();
//
//				}
//        //If we have multiple matches then give
//        //the user a choice
//				else
//				if(candidates.Count > 0)
//				{
//					foreach(var candidate in candidates)
//					{
//						if(candidate != null && candidate.Script != null && GUILayout.Button("Use " + candidate.Script.name))
//						{
//							//Configure the script
//							script.objectReferenceValue = candidate.Script;
//
//							serializedObject.ApplyModifiedProperties();
//							serializedObject.UpdateIfDirtyOrScript();
//    
//						}
//					}
//				}
//        //Otherwise tell them we failed
//				else
//				{
//					GUILayout.Label("> No suitable scripts were found");
//				}
//				break;
//			}
//		}
	}

	private bool AreAnyScriptsMissing()
	{
		//@TODO: fix this test
		return target.GetType() != typeof(OCType) || target.GetType() == typeof(MonoBehaviour);
	}

	void DisplayInspectorGUI()
	{
		//base.OnInspectorGUI();
		DrawDefaultInspector();

		OCExposePropertiesAttribute.Expose(m_ReadAndWriteProperties);
	}

	void SerializeAndHidePrivateDataMembers(System.Object obj)
	{
		if(obj == null)
		{
			return;
		}
 
		List< FieldInfo > fields = new List<FieldInfo>();
 
		Type objType = obj.GetType();

		FieldInfo[] infos = objType.GetFields
    (
      BindingFlags.NonPublic
    | BindingFlags.Instance
    );

		foreach(FieldInfo info in infos)
		{

			object[] attributes = info.GetCustomAttributes(true);

		}




	}





	/////////////////////////////////////////////////////////////////////////////

  #endregion

	/////////////////////////////////////////////////////////////////////////////

}// class OCEditor

}// namespace EditorExtensions

}// namespace OpenCog